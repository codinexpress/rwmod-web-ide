<!DOCTYPE html>
<html>
<head>
  <title>Editor - RW Mod IDE</title>
  <link rel="stylesheet" href="css/style.css">
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    .file-actions { margin-bottom: 10px; display: flex; gap: 5px; flex-wrap: wrap; }
    .file-actions button { font-size: 0.8em; padding: 3px 6px; }
    #fileList li button.delete-btn { margin-left: 10px; border: none; background: transparent; cursor: pointer; padding: 0; font-size: 0.9em; }
    #fileList li button.delete-btn:hover { color: red; }
    .file-icon { margin-right: 6px; display: inline-block; width: 20px; text-align: center; }
    #currentPathDisplay { margin-bottom: 8px; padding: 4px; background-color: #eee; font-size: 0.9em; border-radius: 3px; }
    #fileList .up-level { cursor: pointer; font-weight: bold; color: #007bff; }
    #fileList .up-level:hover { background-color: #e0e0e0; }
    .folder-toggle { cursor: pointer; margin-right: 4px; width: 12px; display: inline-block; user-select:none;}
    #fileList ul { padding-left: 0; list-style-type: none;} 
    #fileList li { display: flex; align-items: center; }
    #fileList li .item-content { flex-grow: 1; display: flex; align-items: center; padding: 2px 0; }
    #fileList li .item-content:hover { background-color: #f0f0f0; } 
    #fileList li > ul > li { padding-left: 20px !important; }

    .context-menu-btn {
      background: none;
      border: none;
      cursor: pointer;
      font-weight: bold;
      padding: 0 5px;
      margin-left: 5px;
      font-size: 1em;
      line-height: 1;
      visibility: hidden; /* Initially hidden */
    }
    #fileList li:hover .context-menu-btn {
        visibility: visible; /* Show on hover of li */
    }
    .explorer-item-menu {
      display: none;
      position: absolute;
      background-color: white;
      border: 1px solid #ccc;
      z-index: 100; /* Ensure it's above other items */
      min-width: 100px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
    }
    .explorer-item-menu ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .explorer-item-menu li {
      padding: 8px 12px;
      cursor: pointer;
      font-size: 0.9em;
    }
    .explorer-item-menu li:hover {
      background-color: #f0f0f0;
    }

    /* Modal Base */
    .modal {
      display: none; 
      position: fixed; 
      z-index: 1000; 
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto; 
      background-color: rgba(0,0,0,0.4); 
    }
    .modal-content {
      background-color: #fefefe;
      margin: 10% auto; 
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 500px;
      border-radius: 5px;
      box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);
    }
    .modal-close-btn {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
    }
    .modal-close-btn:hover,
    .modal-close-btn:focus {
      color: black;
      text-decoration: none;
      cursor: pointer;
    }

    /* Move Modal Specific */
    #moveModalTitle {
      margin-top: 0;
    }
    #moveModalCurrentPath {
      padding: 8px;
      background-color: #eee;
      margin-bottom: 10px;
      border-radius: 3px;
      font-family: monospace;
      font-size: 0.9em;
    }
    #moveModalDirectoryList {
      list-style-type: none;
      padding: 0;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ddd;
      margin-bottom: 15px;
    }
    #moveModalDirectoryList li {
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
    }
    #moveModalDirectoryList li:last-child {
      border-bottom: none;
    }
    #moveModalDirectoryList li:hover {
      background-color: #f0f0f0;
    }
    #moveModalDirectoryList li.empty-message {
      font-style: italic;
      color: #777;
      cursor: default;
    }
     #moveModalDirectoryList li.up-level-modal:hover {
      background-color: #e6f7ff; /* Light blue hover for up-level */
    }
    .move-modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
  </style>
</head>
<body>
  <nav>
    <a href="index.html">Home</a>
    <button id="closeProjectBtn">Close Project</button>
  </nav>

  <div class="editor-container"> 
    <div id="fileExplorer">
      <h3>Project Files</h3>
      <div id="currentPathDisplay">Root</div>
      <div class="file-actions">
        <button id="newFileBtn" title="New File">üìÑ+ New File</button>
        <button id="newDirectoryBtn" title="New Directory">üìÅ+ New Dir</button>
        <button id="uploadFilesBtn" title="Upload File(s)">‚òÅÔ∏è‚Üë Upload Files</button>
        <input type="file" id="uploadFilesInput" multiple hidden>
        <button id="uploadFolderBtn" title="Upload Folder">üìÅ‚Üë Upload Folder</button>
        <input type="file" id="uploadFolderInput" webkitdirectory directory hidden>
        <button id="exportProjectBtn" title="Export Project">üì¶ Export Project</button>
      </div>
      <ul id="fileList"></ul>
    </div>
    <div class="editor-area">
      <div id="monacoEditorContainer" style="height: 100%; width: 100%; border: 1px solid #ccc;"></div>
      <div class="editor-controls">
        <button id="saveButton">Save File</button>
        <div id="currentFileDisplay">Editing: None</div>
        <div id="editorMessage" class="user-message"></div>
        <label for="themeSelector" style="margin-left: 10px;">Theme:</label>
        <select id="themeSelector">
          <option value="vs-dark">Dark</option>
          <option value="vs">Light</option>
          <option value="hc-black">High Contrast Dark</option>
          <option value="hc-light">High Contrast Light</option>
        </select>
        <label for="fontSizeInput" id="fontSizeLabel">Font Size:</label>
        <button id="decreaseFontSizeBtn">-</button>
        <input type="number" id="fontSizeInput" value="14" min="8" max="72">
        <button id="increaseFontSizeBtn">+</button>
      </div>
    </div>
  </div>

  <!-- Image Viewer Modal -->
  <div id="imageViewerModal" style="display:none; position:fixed; z-index:1000; left:0; top:0; width:100%; height:100%; overflow:auto; background-color:rgba(0,0,0,0.7);">
    <span id="closeImageViewer" style="position:absolute; top:20px; right:35px; color:#f1f1f1; font-size:40px; font-weight:bold; cursor:pointer;">&times;</span>
    <img id="modalImageContent" style="margin:auto; display:block; max-width:80%; max-height:80%; position:relative; top:50%; transform:translateY(-50%);">
    <div id="imageCaption" style="text-align:center; color:#ccc; padding:10px 0; position:absolute; bottom:20px; width:100%;"></div>
  </div>

  <!-- Move Item Modal -->
  <div id="moveItemModal" class="modal">
    <div class="modal-content">
      <span id="moveModalCloseBtn" class="modal-close-btn">&times;</span>
      <h4 id="moveModalTitle">Move Item</h4>
      <div id="moveModalCurrentPath">/</div>
      <ul id="moveModalDirectoryList">
        <!-- Directory items will be populated here -->
      </ul>
      <div class="move-modal-actions">
        <button id="moveModalNewFolderBtn">New Folder</button>
        <button id="moveModalMoveHereBtn" class="primary-action">Move Here</button>
        <button id="moveModalCancelBtn">Cancel</button>
      </div>
    </div>
  </div>


  <script>
    const fileListUl = document.getElementById('fileList');
    const saveButton = document.getElementById('saveButton');
    const newFileBtn = document.getElementById('newFileBtn');
    const newDirectoryBtn = document.getElementById('newDirectoryBtn');
    const uploadFilesBtn = document.getElementById('uploadFilesBtn'); 
    const uploadFilesInput = document.getElementById('uploadFilesInput'); 
    const uploadFolderBtn = document.getElementById('uploadFolderBtn'); 
    const uploadFolderInput = document.getElementById('uploadFolderInput'); 
    const exportProjectBtn = document.getElementById('exportProjectBtn');
    const editorMessageDiv = document.getElementById('editorMessage');
    const currentFileDisplayDiv = document.getElementById('currentFileDisplay');
    const currentPathDisplayElement = document.getElementById('currentPathDisplay');
    const fontSizeInput = document.getElementById('fontSizeInput');
    const increaseFontSizeBtn = document.getElementById('increaseFontSizeBtn');
    const decreaseFontSizeBtn = document.getElementById('decreaseFontSizeBtn');
    
    // Move Modal Elements
    const moveItemModal = document.getElementById('moveItemModal');
    const moveModalCloseBtn = document.getElementById('moveModalCloseBtn');
    const moveModalTitleElement = document.getElementById('moveModalTitle');
    const moveModalCurrentPathElement = document.getElementById('moveModalCurrentPath');
    const moveModalDirectoryListElement = document.getElementById('moveModalDirectoryList');
    const moveModalNewFolderBtn = document.getElementById('moveModalNewFolderBtn');
    const moveModalMoveHereBtn = document.getElementById('moveModalMoveHereBtn');
    const moveModalCancelBtn = document.getElementById('moveModalCancelBtn');
    const closeProjectBtn = document.getElementById('closeProjectBtn');

    const API_BASE_URL = 'http://localhost:3000/api'; 

    let currentProject = '';
    let currentOpenFileFullPath = []; 
    let editor; 
    let storageType = 'backend'; 
    let rootProjectDirHandle = null; 
    let currentDirectoryHandle = null; 
    let currentPathSegments = [];   
    let expandedFolders = {}; 
    const imageExtensions = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'bmp', 'ico'];
    let currentOpenContextMenu = null; 

    // Move Modal State
    let sourceItemPathArrayToMove = [];
    let sourceItemKindToMove = '';
    let sourceItemNameToMove = '';
    let moveModalCurrentBrowsingPathArray = [];


    function displayEditorMessage(message, type = 'error') { 
      editorMessageDiv.textContent = message;
      editorMessageDiv.className = 'user-message ' + type; 
      editorMessageDiv.style.display = 'inline-block';
      setTimeout(() => {
        editorMessageDiv.style.display = 'none';
        editorMessageDiv.textContent = '';
        editorMessageDiv.className = 'user-message'; 
      }, 6000); 
    }

    function updateCurrentFileDisplay(itemPathArray = [], isImage = false) {
      currentOpenFileFullPath = [...itemPathArray];
      const displayPath = itemPathArray.join('/') || 'None';
      const actionText = isImage ? "Viewing: " : "Editing: ";
      currentFileDisplayDiv.textContent = actionText + displayPath;
      if (itemPathArray.length === 0 && editor) { 
         editor.setValue('// Select or create a file to begin.');
         document.getElementById('monacoEditorContainer').style.display = 'block'; // Ensure editor is visible
      }
    }
    
    function updatePathDisplay() {
        currentPathDisplayElement.textContent = `${currentProject} / ${currentPathSegments.join(' / ')}`;
    }

    // --- Backend-based file operations (legacy) ---
    function fetchProjectFilesBackend(projectName) {
      fileListUl.innerHTML = ''; 
      currentPathSegments = []; 
      updatePathDisplay();
       fetch(`${API_BASE_URL}/files?project=${encodeURIComponent(projectName)}`)
        .then(r => r.ok ? r.json() : r.json().then(e => Promise.reject(e)))
        .then(files => { 
          if (files.length === 0) {
            fileListUl.innerHTML = '<li>No files in this project.</li>'; return;
          }
          files.sort((a,b) => a.isDirectory === b.isDirectory ? a.name.localeCompare(b.name) : a.isDirectory ? -1 : 1);
          files.forEach(file => { 
            const li = document.createElement('li');
            const iconSpan = document.createElement('span');
            iconSpan.className = 'file-icon';
            let iconChar = file.isDirectory ? 'üìÅ ' : 'üìÑ ';
            const fileExtension = file.name.split('.').pop().toLowerCase();
            if (!file.isDirectory) {
                if (imageExtensions.includes(fileExtension)) iconChar = 'üñºÔ∏è ';
                else if (fileExtension === 'ini') iconChar = 'üìú ';
                else if (fileExtension === 'lua') iconChar = 'üåô ';
            }
            iconSpan.textContent = iconChar;
            li.appendChild(iconSpan);

            const nameSpan = document.createElement('span');
            nameSpan.textContent = file.name;
            li.appendChild(nameSpan);
            li.className = file.isDirectory ? 'type-directory' : 'type-file';
            if (!file.isDirectory) {
              // Backend mode doesn't have image viewer, so all files load in editor
              li.onclick = () => loadFileContentBackend(projectName, [file.name]);
            }
            fileListUl.appendChild(li);
          });
        })
        .catch(e => displayEditorMessage(`Failed to load project files (backend): ${e.message || 'Unknown error'}`, 'error'));
    }

    function loadFileContentBackend(projectName, itemPathArray) {
      const fileName = itemPathArray.join('/'); 
      if (editor) {
          document.getElementById('monacoEditorContainer').style.display = 'block'; // Show editor
          editor.setValue('// Loading (backend)...'); 
      }
      fetch(`${API_BASE_URL}/file?project=${encodeURIComponent(projectName)}&filename=${encodeURIComponent(fileName)}`)
        .then(r => r.ok ? r.text() : r.text().then(e => Promise.reject(new Error(e))))
        .then(content => {
          if (editor) {
            const oldModel = editor.getModel();
            if (oldModel) {
              oldModel.dispose();
            }
            const fileUri = monaco.Uri.file(fileName); // Use full path for URI
            const newModel = monaco.editor.createModel(content, undefined, fileUri);
            editor.setModel(newModel);
          }
          updateCurrentFileDisplay(itemPathArray); 
        })
        .catch(e => {
          displayEditorMessage(`Failed to load file '${fileName}' (backend): ${e.message || 'Unknown error'}`, 'error');
          if (editor) editor.setValue(`// Could not load ${fileName}.`); 
          updateCurrentFileDisplay([]); 
        });
    }
    
    // --- OPFS-based file operations (with Tree View & Image Viewer) ---
    async function renderExplorerItem(entry, parentUlElement, projectName, entryPathArray, depth) {
        const li = document.createElement('li');
        const itemContentDiv = document.createElement('div');
        itemContentDiv.className = 'item-content';
        const fullPathKey = entryPathArray.join('/');
        const iconSpan = document.createElement('span');
        iconSpan.className = 'file-icon';

        if (entry.kind === 'directory') {
            const toggleSpan = document.createElement('span');
            toggleSpan.className = 'folder-toggle';
            toggleSpan.textContent = expandedFolders[fullPathKey] ? '‚ñº' : '‚ñ∂';
            toggleSpan.onclick = async (e) => {
                e.stopPropagation();
                expandedFolders[fullPathKey] = !expandedFolders[fullPathKey];
                const subList = li.querySelector('ul');
                if (expandedFolders[fullPathKey] && !subList) { 
                    await renderChildren(entry, li, projectName, entryPathArray, depth);
                    toggleSpan.textContent = '‚ñº'; 
                } else if (subList) {
                    subList.style.display = expandedFolders[fullPathKey] ? 'block' : 'none';
                    toggleSpan.textContent = expandedFolders[fullPathKey] ? '‚ñº' : '‚ñ∂';
                }
            };
            itemContentDiv.appendChild(toggleSpan);
            iconSpan.textContent = 'üìÅ ';
            li.className = 'type-directory';
            itemContentDiv.onclick = (e) => toggleSpan.click(); 
        } else { 
            const fileExtension = entry.name.split('.').pop().toLowerCase();
            if (imageExtensions.includes(fileExtension)) {
                iconSpan.textContent = 'üñºÔ∏è ';
                itemContentDiv.onclick = () => showImageViewer(projectName, entryPathArray);
            } else {
                switch (fileExtension) {
                    case 'txt': iconSpan.textContent = 'üìÑ '; break; case 'ini': iconSpan.textContent = 'üìú '; break;
                    case 'md': iconSpan.textContent = 'üìù '; break; 
                    case 'lua': iconSpan.textContent = 'üåô '; break; case 'js': iconSpan.textContent = 'üü° '; break;
                    case 'json': iconSpan.textContent = '{ } '; break; case 'html': iconSpan.textContent = 'üåê '; break;
                    case 'css': iconSpan.textContent = 'üé® '; break; default: iconSpan.textContent = 'üìé '; break;
                }
                itemContentDiv.onclick = () => loadOpfsFileContent(projectName, entryPathArray);
            }
            li.className = 'type-file';
            itemContentDiv.style.cursor = 'pointer';
        }
        
        itemContentDiv.appendChild(iconSpan);
        const nameSpan = document.createElement('span');
        nameSpan.textContent = entry.name;
        itemContentDiv.appendChild(nameSpan);
        li.appendChild(itemContentDiv);

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.textContent = 'üóëÔ∏è';
        deleteBtn.title = `Delete ${entry.name}`;
        deleteBtn.onclick = (e) => { 
            e.stopPropagation(); 
            deleteOpfsEntry(projectName, entryPathArray, entry.kind); 
        };
        li.appendChild(deleteBtn);

        const moveBtn = document.createElement('button');
        moveBtn.className = 'move-btn'; // Add a class for styling if needed
        moveBtn.textContent = '‚û°Ô∏è'; // Or use text like "Move"
        moveBtn.title = `Move ${entry.name}`;
        // moveBtn.style.marginLeft = '5px'; // Will be handled by general button styling in li or specific class
        moveBtn.onclick = (e) => {
            e.stopPropagation();
            handleMoveEntry(projectName, entryPathArray, entry.kind);
        };
        li.appendChild(moveBtn);

        // Context Menu Button (...)
        const contextMenuBtn = document.createElement('button');
        contextMenuBtn.textContent = '...';
        contextMenuBtn.className = 'context-menu-btn';
        contextMenuBtn.title = 'More options';
        li.appendChild(contextMenuBtn);

        // Context Menu Structure (hidden by default)
        const menuDiv = document.createElement('div');
        menuDiv.className = 'explorer-item-menu';
        const menuUl = document.createElement('ul');

        const actions = [
            { 
                name: 'Rename', 
                action: async () => {
                    const oldName = entry.name;
                    const newName = prompt(`Enter new name for "${oldName}":`, oldName);

                    if (!newName || newName.trim() === '' || newName === oldName) {
                        if (newName === oldName) displayEditorMessage('New name is the same as the old name.', 'error');
                        return;
                    }
                    if (newName.includes('/') || newName.includes('\\') || newName === '.' || newName === '..') {
                        displayEditorMessage('Invalid name. Cannot contain slashes or be "." or "..".', 'error');
                        return;
                    }

                    // entryPathArray is the full path to the item including its current name
                    // currentPathSegments is the path to the directory currently listed in the explorer
                    await renameOpfsEntry(projectName, entryPathArray, newName.trim(), entry.kind, currentPathSegments);
                } 
            },
            { name: 'Move', action: () => { handleMoveEntry(projectName, entryPathArray, entry.kind); } },
            { name: 'Delete', action: () => { deleteOpfsEntry(projectName, entryPathArray, entry.kind); } }
        ];

        actions.forEach(actionItem => {
            const menuLi = document.createElement('li');
            menuLi.textContent = actionItem.name;
            menuLi.onclick = (e) => {
                e.stopPropagation();
                actionItem.action();
                closeCurrentContextMenu();
            };
            menuUl.appendChild(menuLi);
        });

        menuDiv.appendChild(menuUl);
        li.appendChild(menuDiv); // Append to li, it will be positioned absolutely

        contextMenuBtn.onclick = (e) => {
            e.stopPropagation(); // Prevent li click event
            if (currentOpenContextMenu && currentOpenContextMenu !== menuDiv) {
                currentOpenContextMenu.style.display = 'none';
            }
            menuDiv.style.display = menuDiv.style.display === 'block' ? 'none' : 'block';
            if (menuDiv.style.display === 'block') {
                currentOpenContextMenu = menuDiv;
                // Position menu - this is a basic positioning, might need refinement
                const rect = contextMenuBtn.getBoundingClientRect();
                menuDiv.style.top = (rect.bottom + window.scrollY) + 'px';
                menuDiv.style.left = (rect.left + window.scrollX - menuDiv.offsetWidth + rect.width) + 'px';
            } else {
                currentOpenContextMenu = null;
            }
        };
        
        // Right-click context menu for the li item
        li.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();

            const thisMenuDiv = li.querySelector('.explorer-item-menu');
            if (!thisMenuDiv) return;

            if (currentOpenContextMenu && currentOpenContextMenu !== thisMenuDiv) {
                closeCurrentContextMenu(); // Close any other menu
            }
            
            // Position the menu at the cursor
            // Consider scroll offsets if #fileList or a parent is the scroll container
            const fileExplorerRect = document.getElementById('fileExplorer').getBoundingClientRect();
            thisMenuDiv.style.left = (e.clientX - fileExplorerRect.left) + 'px';
            thisMenuDiv.style.top = (e.clientY - fileExplorerRect.top) + 'px'; // Adjust if #fileExplorer has padding-top

            thisMenuDiv.style.display = 'block';
            currentOpenContextMenu = thisMenuDiv;
        });

        parentUlElement.appendChild(li);

        if (entry.kind === 'directory' && expandedFolders[fullPathKey]) {
            await renderChildren(entry, li, projectName, entryPathArray, depth);
        }
    }

    async function renderChildren(parentEntry, parentLiElement, projectName, parentPathArray, depth) {
        let subList = parentLiElement.querySelector('ul');
        if (!subList) {
            subList = document.createElement('ul');
            parentLiElement.appendChild(subList);
        }
        subList.innerHTML = ''; 
        try {
            let parentDirHandle = rootProjectDirHandle; 
            for (const segment of parentPathArray) {
                parentDirHandle = await parentDirHandle.getDirectoryHandle(segment);
            }
            const childEntries = [];
            for await (const childEntry of parentDirHandle.values()) { childEntries.push(childEntry); }
            childEntries.sort((a,b) => a.kind === b.kind ? a.name.localeCompare(b.name) : a.kind === 'directory' ? -1 : 1);
            for (const childEntry of childEntries) {
                await renderExplorerItem(childEntry, subList, projectName, [...parentPathArray, childEntry.name], depth + 1);
            }
        } catch (err) { console.error(`Error rendering children for ${parentPathArray.join('/')}:`, err); }
    }

    async function getDirectoryHandleByPath(baseHandle, pathArray, create = false) {
        let currentHandle = baseHandle;
        for (const segment of pathArray) {
            if (!segment) continue; // Skip empty segments, e.g., from leading/trailing slashes
            try {
                currentHandle = await currentHandle.getDirectoryHandle(segment, { create });
            } catch (error) {
                // If create is true and it still fails, or if create is false and it's not found
                if (create || error.name !== 'NotFoundError') {
                    console.error(`Error getting/creating directory handle for "${segment}" in path "${pathArray.join('/')}"`, error);
                    throw new Error(`Failed to get or create directory handle for "${segment}": ${error.message}`);
                }
                // If create is false and not found, this is an error for the caller to decide on
                throw error; 
            }
        }
        return currentHandle;
    }

    async function moveOpfsFile(sourceProjectName, sourcePathArray, targetDirectoryHandle, newFileName) {
        const sourceFileName = sourcePathArray[sourcePathArray.length - 1];
        let sourceParentDirHandle;
        try {
            // 1. Get source file handle and its parent
            const sourceFileHandle = await getHandleFromPath(sourceProjectName, sourcePathArray, false, 'file');
            const sourceParentPathArray = sourcePathArray.slice(0, -1);
            if (sourceParentPathArray.length === 0) {
                sourceParentDirHandle = rootProjectDirHandle;
            } else {
                sourceParentDirHandle = await getDirectoryHandleByPath(rootProjectDirHandle, sourceParentPathArray, false);
            }

            // 2. Read file content
            const file = await sourceFileHandle.getFile();
            const content = await file.arrayBuffer(); // Or .text() if appropriate, but ArrayBuffer is more generic

            // 3. Create new file in targetDirectoryHandle
            const newFileHandle = await targetDirectoryHandle.getFileHandle(newFileName, { create: true });
            const writable = await newFileHandle.createWritable();
            await writable.write(content);
            await writable.close();

            // 4. If successful, delete original file
            await sourceParentDirHandle.removeEntry(sourceFileName);

            displayEditorMessage(`File '${sourceFileName}' moved to '${newFileName}' in target directory.`, 'success');
            return true;
        } catch (error) {
            console.error(`Error moving file '${sourceFileName}' to '${newFileName}':`, error);
            displayEditorMessage(`Error moving file: ${error.message}`, 'error');
            // Attempt to clean up partially created new file if it exists and error occurred after its creation attempt
            try {
                await targetDirectoryHandle.removeEntry(newFileName);
                console.warn(`Cleaned up partially created file '${newFileName}' after move error.`);
            } catch (cleanupError) {
                // Ignore cleanup error if file wasn't created or another issue
            }
            return false;
        }
    }

    async function moveOpfsDirectory(sourceProjectName, sourcePathArray, targetParentDirHandle, newDirectoryName) {
        const sourceDirName = sourcePathArray[sourcePathArray.length - 1];
        let sourceDirHandle;
        let sourceParentHandle;

        try {
            // 1. Get source directory handle and its parent
            sourceDirHandle = await getHandleFromPath(sourceProjectName, sourcePathArray, false, 'directory');
            const sourceParentPathArray = sourcePathArray.slice(0, -1);
            if (sourceParentPathArray.length === 0) {
                sourceParentHandle = rootProjectDirHandle;
            } else {
                sourceParentHandle = await getDirectoryHandleByPath(rootProjectDirHandle, sourceParentPathArray, false);
            }
            
            // 2. Create the new target directory within targetParentDirHandle
            const newTargetDirHandle = await targetParentDirHandle.getDirectoryHandle(newDirectoryName, { create: true });

            // 3. Iterate over entries in sourceDirHandle
            for await (const entry of sourceDirHandle.values()) {
                const entrySourcePathArray = [...sourcePathArray, entry.name];
                if (entry.kind === 'file') {
                    const success = await moveOpfsFile(sourceProjectName, entrySourcePathArray, newTargetDirHandle, entry.name);
                    if (!success) {
                        throw new Error(`Failed to move inner file '${entry.name}' during directory move.`);
                    }
                } else if (entry.kind === 'directory') {
                    const success = await moveOpfsDirectory(sourceProjectName, entrySourcePathArray, newTargetDirHandle, entry.name);
                    if (!success) {
                        throw new Error(`Failed to move inner directory '${entry.name}' during directory move.`);
                    }
                }
            }

            // 4. After all contents are moved, delete the original source directory
            await sourceParentHandle.removeEntry(sourceDirName, { recursive: true }); // recursive might not be needed if empty

            displayEditorMessage(`Directory '${sourceDirName}' and its contents moved to '${newDirectoryName}'.`, 'success');
            return true;
        } catch (error) {
            console.error(`Error moving directory '${sourceDirName}' to '${newDirectoryName}':`, error);
            displayEditorMessage(`Error moving directory: ${error.message}`, 'error');
            // Attempt to clean up partially created new directory
            try {
                await targetParentDirHandle.removeEntry(newDirectoryName, { recursive: true });
                console.warn(`Cleaned up partially created directory '${newDirectoryName}' after move error.`);
            } catch (cleanupError) {
                // Ignore cleanup error
            }
            return false;
        }
    }

    async function handleMoveEntry(projectNameFromCall, sourcePathArray, itemKind) {
        // This function will now primarily open the modal. 
        // The actual move logic will be triggered by the modal's "Move Here" button.
        if (!rootProjectDirHandle) {
            displayEditorMessage('OPFS not initialized. Cannot move.', 'error');
            return;
        }
        if (!projectNameFromCall || !sourcePathArray || !itemKind) {
            displayEditorMessage('Move parameters missing.', 'error');
            console.error("handleMoveEntry called with invalid parameters:", projectNameFromCall, sourcePathArray, itemKind);
            return;
        }
        openMoveModal(projectNameFromCall, sourcePathArray, itemKind);
    }

    async function openMoveModal(projectName, itemPathArray, itemKind) {
        sourceItemPathArrayToMove = [...itemPathArray];
        sourceItemKindToMove = itemKind;
        sourceItemNameToMove = itemPathArray[itemPathArray.length - 1];

        moveModalTitleElement.textContent = `Move '${sourceItemNameToMove}' to:`;
        moveModalCurrentBrowsingPathArray = []; // Start browsing from root
        
        await populateMoveModalDirectoryList(moveModalCurrentBrowsingPathArray); // Initial population for root
        
        moveItemModal.style.display = 'block';
    }

    function closeMoveModal() {
        moveItemModal.style.display = 'none';
        moveModalDirectoryListElement.innerHTML = ''; // Clear list
    }

    async function populateMoveModalDirectoryList(pathArrayForModalListing) {
        if (!rootProjectDirHandle) {
            displayEditorMessage('OPFS not available.', 'error');
            moveModalDirectoryListElement.innerHTML = '<li class="empty-message">OPFS not available.</li>';
            return;
        }
        moveModalCurrentPathElement.textContent = `/${pathArrayForModalListing.join('/')}`;
        moveModalDirectoryListElement.innerHTML = ''; // Clear previous list

        let currentDirHandleInModal;
        try {
            if (pathArrayForModalListing.length === 0) {
                currentDirHandleInModal = rootProjectDirHandle;
            } else {
                currentDirHandleInModal = await getDirectoryHandleByPath(rootProjectDirHandle, pathArrayForModalListing, false);
            }

            // "Up one level" option
            if (pathArrayForModalListing.length > 0) {
                const upLi = document.createElement('li');
                upLi.textContent = '‚¨ÜÔ∏è .. (Up one level)';
                upLi.className = 'up-level-modal'; // For specific styling if needed
                upLi.onclick = () => {
                    moveModalCurrentBrowsingPathArray = pathArrayForModalListing.slice(0, -1);
                    populateMoveModalDirectoryList(moveModalCurrentBrowsingPathArray);
                };
                moveModalDirectoryListElement.appendChild(upLi);
            }

            let foundDirectories = false;
            const entries = [];
            for await (const entry of currentDirHandleInModal.values()) {
                if (entry.kind === 'directory') {
                    entries.push(entry);
                }
            }
            entries.sort((a,b) => a.name.localeCompare(b.name)); // Sort directories alphabetically

            for (const entry of entries) {
                foundDirectories = true;
                const li = document.createElement('li');
                li.textContent = `üìÅ ${entry.name}`;
                li.dataset.folderName = entry.name; // Store name for easier access
                li.onclick = () => {
                    moveModalCurrentBrowsingPathArray = [...pathArrayForModalListing, entry.name];
                    populateMoveModalDirectoryList(moveModalCurrentBrowsingPathArray);
                };
                moveModalDirectoryListElement.appendChild(li);
            }

            if (!foundDirectories && pathArrayForModalListing.length === 0 && !moveModalDirectoryListElement.querySelector('.up-level-modal')) {
                 moveModalDirectoryListElement.innerHTML = '<li class="empty-message">Project root is empty.</li>';
            } else if (!foundDirectories && !moveModalDirectoryListElement.querySelector('.up-level-modal')) {
                 moveModalDirectoryListElement.innerHTML = '<li class="empty-message">(This folder is empty)</li>';
            }


        } catch (error) {
            console.error('Error populating move modal directory list:', error);
            displayEditorMessage(`Error listing directories for move: ${error.message}`, 'error');
            moveModalDirectoryListElement.innerHTML = `<li class="empty-message">Error: ${error.message}</li>`;
        }
    }
    
    async function listOpfsProjectFiles(projectName, basePathArray = []) {
        fileListUl.innerHTML = '';
        if (!navigator.storage || !navigator.storage.getDirectory) {
            displayEditorMessage('OPFS API not supported.', 'error'); return;
        }
        try {
            if (!rootProjectDirHandle) { 
                 const opfsRoot = await navigator.storage.getDirectory();
                 rootProjectDirHandle = await opfsRoot.getDirectoryHandle(projectName);
            }
            let targetDirHandle = rootProjectDirHandle;
            for (const segment of basePathArray) {
                targetDirHandle = await targetDirHandle.getDirectoryHandle(segment);
            }
            currentDirectoryHandle = targetDirHandle; 
            currentPathSegments = [...basePathArray]; 
            updatePathDisplay();

            if (basePathArray.length > 0) {
                const upLi = document.createElement('li');
                upLi.className = 'up-level item-content'; 
                const iconSpan = document.createElement('span');
                iconSpan.className = 'file-icon';
                iconSpan.textContent = '‚¨ÜÔ∏è ';
                upLi.appendChild(iconSpan);
                const nameSpan = document.createElement('span');
                nameSpan.textContent = '.. (Up)';
                upLi.appendChild(nameSpan);
                upLi.onclick = () => listOpfsProjectFiles(projectName, basePathArray.slice(0, -1));
                fileListUl.appendChild(upLi);
            }
            
            let fileFoundInOpfs = false;
            const opfsEntries = [];
            for await (const entry of currentDirectoryHandle.values()) {
                opfsEntries.push(entry);
                fileFoundInOpfs = true;
            }
            opfsEntries.sort((a,b) => a.kind === b.kind ? a.name.localeCompare(b.name) : a.kind === 'directory' ? -1 : 1);
            for (const entry of opfsEntries) {
                await renderExplorerItem(entry, fileListUl, projectName, [...basePathArray, entry.name], 0);
            }
            if (!fileFoundInOpfs && basePathArray.length === 0) { 
                fileListUl.innerHTML += '<li>No files in this project. Create one!</li>';
            } else if (!fileFoundInOpfs && basePathArray.length > 0) {
                 fileListUl.innerHTML += '<li style="font-style: italic; padding-left: 20px;">(Folder is empty)</li>';
            }
        } catch (err) { displayEditorMessage(`Error listing OPFS files: ${err.message}`, 'error'); }
    }

    async function addFolderToZip(dirHandle, zip, basePath) {
        for await (const entry of dirHandle.values()) {
            const fullEntryPath = basePath + entry.name;
            if (entry.kind === 'file') {
                try {
                    const fileHandle = await dirHandle.getFileHandle(entry.name);
                    const file = await fileHandle.getFile();
                    const fileContent = await file.arrayBuffer();
                    zip.file(fullEntryPath, fileContent);
                } catch (fileError) {
                    console.error(`Error reading file ${fullEntryPath} for zipping:`, fileError);
                    displayEditorMessage(`Error adding file ${entry.name} to zip: ${fileError.message}`, 'error');
                    // Optionally, decide if one error should stop the whole process
                }
            } else if (entry.kind === 'directory') {
                // JSZip creates folders implicitly if files are added to subpaths.
                // However, explicit creation is fine and ensures empty folders are included.
                zip.folder(fullEntryPath); 
                const subDirHandle = await dirHandle.getDirectoryHandle(entry.name);
                await addFolderToZip(subDirHandle, zip, fullEntryPath + '/');
            }
        }
    }

    async function processProjectExport(projectName, projectDirHandle, format) {
        if (!projectName || !projectDirHandle) {
            displayEditorMessage('Project details not available for export.', 'error');
            return;
        }
        if (typeof JSZip === 'undefined') {
            displayEditorMessage('JSZip library not loaded. Cannot export.', 'error');
            return;
        }

        displayEditorMessage('Starting project export... please wait.', 'success');
        try {
            const zip = new JSZip();
            await addFolderToZip(projectDirHandle, zip, ''); // Start with empty base path

            const blob = await zip.generateAsync({ 
                type: "blob",
                compression: "DEFLATE",
                compressionOptions: { level: 9 } 
            });

            const downloadLink = document.createElement('a');
            downloadLink.href = URL.createObjectURL(blob);
            const fileExtension = format === 'RWMOD' ? '.rwmod' : '.zip';
            downloadLink.download = projectName + fileExtension;
            
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(downloadLink.href);

            displayEditorMessage(`Project "${projectName}" exported successfully as ${downloadLink.download}!`, 'success');

        } catch (error) {
            console.error('Error exporting project:', error);
            displayEditorMessage(`Error exporting project: ${error.message}`, 'error');
        }
    }


    async function renameOpfsEntry(projectName, oldItemPathArray, newName, itemKind, currentExplorerPathArray) {
        if (!rootProjectDirHandle) {
            displayEditorMessage('OPFS not initialized.', 'error');
            return false;
        }

        const oldName = oldItemPathArray[oldItemPathArray.length - 1];
        const parentPathArray = oldItemPathArray.slice(0, -1);
        let parentDirHandle;

        try {
            if (parentPathArray.length === 0) {
                parentDirHandle = rootProjectDirHandle;
            } else {
                parentDirHandle = await getDirectoryHandleByPath(rootProjectDirHandle, parentPathArray, false);
            }

            // Check for name conflict
            try {
                if (itemKind === 'file') {
                    await parentDirHandle.getFileHandle(newName);
                } else { // directory
                    await parentDirHandle.getDirectoryHandle(newName);
                }
                // If above does not throw, item with newName already exists
                displayEditorMessage(`An item named "${newName}" already exists in this location.`, 'error');
                return false;
            } catch (e) {
                if (e.name !== 'NotFoundError') {
                    throw e; // Re-throw other errors
                }
                // NotFoundError is good, means no conflict.
            }

            if (itemKind === 'file') {
                const sourceFileHandle = await parentDirHandle.getFileHandle(oldName);
                const file = await sourceFileHandle.getFile();
                const content = await file.arrayBuffer(); // Use arrayBuffer for broader compatibility

                const newFileHandle = await parentDirHandle.getFileHandle(newName, { create: true });
                const writable = await newFileHandle.createWritable();
                await writable.write(content);
                await writable.close();
                await parentDirHandle.removeEntry(oldName);
            } else { // directory
                const oldDirHandle = await parentDirHandle.getDirectoryHandle(oldName);
                const newDirHandle = await parentDirHandle.getDirectoryHandle(newName, { create: true });

                for await (const entry of oldDirHandle.values()) {
                    const entryOldPath = [...oldItemPathArray, entry.name]; // Full path to the child in old directory
                    if (entry.kind === 'file') {
                        // Pass newDirHandle as the targetDirectoryHandle for moveOpfsFile
                        const success = await moveOpfsFile(projectName, entryOldPath, newDirHandle, entry.name);
                        if (!success) throw new Error(`Failed to move inner file '${entry.name}' during rename.`);
                    } else if (entry.kind === 'directory') {
                        // Pass newDirHandle as the targetParentDirHandle for moveOpfsDirectory
                        const success = await moveOpfsDirectory(projectName, entryOldPath, newDirHandle, entry.name);
                        if (!success) throw new Error(`Failed to move inner directory '${entry.name}' during rename.`);
                    }
                }
                await parentDirHandle.removeEntry(oldName, { recursive: true }); // Should be empty, but recursive for safety
            }

            displayEditorMessage(`${itemKind === 'file' ? 'File' : 'Directory'} "${oldName}" renamed to "${newName}" successfully.`, 'success');

            // Update currentOpenFileFullPath if affected
            const oldFullPathStr = oldItemPathArray.join('/');
            const newFullPathArray = [...parentPathArray, newName];
            const newFullPathStr = newFullPathArray.join('/');

            if (currentOpenFileFullPath.join('/') === oldFullPathStr) {
                updateCurrentFileDisplay(newFullPathArray, imageExtensions.includes(newName.split('.').pop().toLowerCase()));
                 // If the renamed item is a file and was open, update its model URI in Monaco
                if (itemKind === 'file' && editor && editor.getModel()) {
                    const oldModel = editor.getModel();
                    const content = oldModel.getValue();
                    const language = oldModel.getLanguageId(); // Or determine from newName extension
                    oldModel.dispose();
                    const newFileUri = monaco.Uri.file(newFullPathStr);
                    const newModel = monaco.editor.createModel(content, language, newFileUri);
                    editor.setModel(newModel);
                }
            } else if (itemKind === 'directory' && currentOpenFileFullPath.join('/').startsWith(oldFullPathStr + '/')) {
                const relativePath = currentOpenFileFullPath.slice(oldItemPathArray.length);
                const updatedOpenFileFullPath = [...newFullPathArray, ...relativePath];
                const openFileName = updatedOpenFileFullPath[updatedOpenFileFullPath.length-1];
                updateCurrentFileDisplay(updatedOpenFileFullPath, imageExtensions.includes(openFileName.split('.').pop().toLowerCase()));
            }

            // Update expandedFolders
            if (itemKind === 'directory') {
                if (expandedFolders[oldFullPathStr]) {
                    delete expandedFolders[oldFullPathStr];
                    expandedFolders[newFullPathStr] = true;
                }
                const prefixToReplace = oldFullPathStr + '/';
                const newPrefix = newFullPathStr + '/';
                for (const key in expandedFolders) {
                    if (key.startsWith(prefixToReplace)) {
                        const newSubKey = newPrefix + key.substring(prefixToReplace.length);
                        expandedFolders[newSubKey] = expandedFolders[key];
                        delete expandedFolders[key];
                    }
                }
            }
            
            // Refresh the file explorer view based on currentExplorerPathArray
            await listOpfsProjectFiles(projectName, currentExplorerPathArray);
            return true;

        } catch (error) {
            console.error(`Error renaming ${itemKind} '${oldName}' to '${newName}':`, error);
            displayEditorMessage(`Error renaming: ${error.message}`, 'error');
            // Attempt to refresh explorer to reflect any partial changes or current state
            await listOpfsProjectFiles(projectName, currentExplorerPathArray);
            return false;
        }
    }

    async function getHandleFromPath(projectName, itemPathArray, create = false, type = 'file') {
        if (!rootProjectDirHandle) { 
            // This should ideally not happen if operations are guarded by rootProjectDirHandle check
            const opfsRoot = await navigator.storage.getDirectory();
            try {
                rootProjectDirHandle = await opfsRoot.getDirectoryHandle(projectName);
            } catch (e) {
                 // If project folder itself doesn't exist, this is a critical error for any operation.
                console.error(`Project directory "${projectName}" not found or accessible.`, e);
                displayEditorMessage(`Project "${projectName}" not found. Please initialize it first.`, 'error');
                throw new Error(`Project directory "${projectName}" not found.`);
            }
        }
        let currentHandle = rootProjectDirHandle;
        for (let i = 0; i < itemPathArray.length - 1 ; i++) {
            currentHandle = await currentHandle.getDirectoryHandle(itemPathArray[i], {create: false}); 
        }
        const itemName = itemPathArray[itemPathArray.length -1];
        try {
            if (type === 'file') {
                return await currentHandle.getFileHandle(itemName, {create});
            } else { 
                return await currentHandle.getDirectoryHandle(itemName, {create});
            }
        } catch (error) {
             console.error(`Error getting handle for ${type} "${itemName}" in path "${itemPathArray.join('/')}" (create: ${create}):`, error);
             if (error.name === 'NotFoundError' && !create) {
                displayEditorMessage(`${type === 'file' ? 'File' : 'Directory'} "${itemName}" not found at path "${parentPathArray.join('/') || '/'}"`, 'error');
             } else if (create) {
                displayEditorMessage(`Failed to create ${type} "${itemName}" at path "${parentPathArray.join('/') || '/'}": ${error.message}`, 'error');
             } else {
                displayEditorMessage(`Error accessing ${type} "${itemName}": ${error.message}`, 'error');
             }
             throw error; // Re-throw to be handled by caller
        }
    }

    async function loadOpfsFileContent(projectName, itemPathArray) {
        const shortFileName = itemPathArray[itemPathArray.length -1];
        if (editor) {
            document.getElementById('monacoEditorContainer').style.display = 'block'; // Show editor
            editor.setValue(`// Loading ${shortFileName} (OPFS)...`);
        }
        try {
            const fileHandle = await getHandleFromPath(projectName, itemPathArray, false, 'file');
            const file = await fileHandle.getFile();
            const content = await file.text();
            if (editor) {
                const oldModel = editor.getModel();
                if (oldModel) {
                    oldModel.dispose();
                }
                const fullPath = itemPathArray.join('/');
                const fileUri = monaco.Uri.file(fullPath);
                const newModel = monaco.editor.createModel(content, undefined, fileUri);
                editor.setModel(newModel);
            }
            updateCurrentFileDisplay(itemPathArray);
        } catch (err) {
            displayEditorMessage(`Error loading OPFS file ${shortFileName}: ${err.message}`, 'error');
            if (editor) editor.setValue(`// Could not load ${shortFileName} from OPFS.`);
            updateCurrentFileDisplay([]);
        }
    }
    
    async function showImageViewer(projectName, imagePathArray) {
        const imageName = imagePathArray[imagePathArray.length - 1];
        try {
            const fileHandle = await getHandleFromPath(projectName, imagePathArray, false, 'file');
            const file = await fileHandle.getFile();

            const modal = document.getElementById('imageViewerModal');
            const modalImg = document.getElementById('modalImageContent');
            const captionText = document.getElementById('imageCaption');
            const closeModalSpan = document.getElementById('closeImageViewer');

            if (modalImg.src && modalImg.src.startsWith('blob:')) {
                URL.revokeObjectURL(modalImg.src);
            }

            const imageUrl = URL.createObjectURL(file);
            modalImg.src = imageUrl;
            captionText.textContent = imageName;
            modal.style.display = 'block';
            document.getElementById('monacoEditorContainer').style.display = 'none'; // Hide editor

            closeModalSpan.onclick = () => { 
                modal.style.display = 'none'; 
                URL.revokeObjectURL(modalImg.src); 
                document.getElementById('monacoEditorContainer').style.display = 'block'; // Show editor
            };
            // Use a named function for the modal click to allow removal if needed later, though not strictly necessary here
            function modalClickListener(event) {
                if (event.target === modal) { 
                    modal.style.display = 'none'; 
                    URL.revokeObjectURL(modalImg.src); 
                    document.getElementById('monacoEditorContainer').style.display = 'block'; // Show editor
                } 
            }
            modal.onclick = modalClickListener;
            updateCurrentFileDisplay(imagePathArray, true); // true indicates it's an image
        } catch (err) {
            displayEditorMessage(`Error displaying image ${imageName}: ${err.message}`, 'error');
            console.error(err);
            document.getElementById('monacoEditorContainer').style.display = 'block'; // Ensure editor is visible on error
        }
    }


    async function saveOpfsFile(projectName, itemPathArray, fileContent) {
        if (!projectName || itemPathArray.length === 0) {
            displayEditorMessage('Cannot save: No project or file specified.', 'error'); return;
        }
        const shortFileName = itemPathArray[itemPathArray.length - 1];
        try {
            const fileHandle = await getHandleFromPath(projectName, itemPathArray, true, 'file');
            const writable = await fileHandle.createWritable();
            await writable.write(fileContent);
            await writable.close();
            displayEditorMessage(`File '${shortFileName}' saved successfully to OPFS!`, 'success');
        } catch (err) { displayEditorMessage(`Error saving OPFS file ${shortFileName}: ${err.message}`, 'error'); }
    }

    newFileBtn.addEventListener('click', async () => {
        if (storageType !== 'opfs' || !currentProject || !currentDirectoryHandle) {
            displayEditorMessage('New file: OPFS project & folder must be selected.', 'error'); return;
        }
        const newFileName = prompt('Enter new file name (e.g., script.lua):');
        if (!newFileName || newFileName.trim() === '') return;
        if (newFileName.includes('/') || newFileName.includes('\\') || newFileName === '.' || newFileName === '..') {
            displayEditorMessage('Invalid file name.', 'error'); return;
        }
        try {
            const itemPathArray = [...currentPathSegments, newFileName];
            try { await getHandleFromPath(currentProject, itemPathArray, false, 'file'); 
                  displayEditorMessage(`File '${newFileName}' already exists here.`, 'error'); return; } 
            catch (e) { if (e.name !== 'NotFoundError') throw e; }
            
            const newFileHandle = await getHandleFromPath(currentProject, itemPathArray, true, 'file');
            displayEditorMessage(`File '${newFileName}' created.`, 'success');
            await listOpfsProjectFiles(currentProject, currentPathSegments); 
            loadOpfsFileContent(currentProject, itemPathArray); 
        } catch (err) { displayEditorMessage(`Error creating file '${newFileName}': ${err.message}`, 'error'); }
    });

    newDirectoryBtn.addEventListener('click', async () => {
        if (storageType !== 'opfs' || !currentProject || !currentDirectoryHandle) {
            displayEditorMessage('New directory: OPFS project & folder must be selected.', 'error'); return;
        }
        const newDirName = prompt('Enter new directory name:');
        if (!newDirName || newDirName.trim() === '') return;
        if (newDirName.includes('/') || newDirName.includes('\\') || newDirName === '.' || newDirName === '..') {
            displayEditorMessage('Invalid directory name.', 'error'); return;
        }
        try {
            const itemPathArray = [...currentPathSegments, newDirName];
            try { await getHandleFromPath(currentProject, itemPathArray, false, 'directory');
                  displayEditorMessage(`Directory '${newDirName}' already exists here.`, 'error'); return; }
            catch (e) { if (e.name !== 'NotFoundError') throw e; }
            const newDirHandle = await getHandleFromPath(currentProject, itemPathArray, true, 'directory');
            displayEditorMessage(`Directory '${newDirName}' created.`, 'success');
            await listOpfsProjectFiles(currentProject, currentPathSegments);
        } catch (err) { displayEditorMessage(`Error creating directory '${newDirName}': ${err.message}`, 'error');}
    });

    async function deleteOpfsEntry(projectName, itemPathArray, itemKind) {
        const itemName = itemPathArray[itemPathArray.length -1];
        if (!confirm(`Are you sure you want to delete ${itemKind} '${itemName}'?`)) return;
        try {
            const parentPathArray = itemPathArray.slice(0, -1);
            let parentDirHandle = rootProjectDirHandle;
            for(const segment of parentPathArray) {
                parentDirHandle = await parentDirHandle.getDirectoryHandle(segment);
            }
            
            await parentDirHandle.removeEntry(itemName, { recursive: itemKind === 'directory' }); 
            displayEditorMessage(`${itemKind} '${itemName}' deleted.`, 'success');
            const deletedFullPathStr = itemPathArray.join('/');
            const currentOpenPathStr = currentOpenFileFullPath.join('/');
            if (deletedFullPathStr === currentOpenPathStr && itemKind === 'file') { 
                updateCurrentFileDisplay([], false); // Clear display, not an image
                if(editor) editor.setValue('// Current file was deleted.');
                document.getElementById('monacoEditorContainer').style.display = 'block'; // Ensure editor is visible
            } else if (itemKind === 'directory' && currentOpenPathStr.startsWith(deletedFullPathStr + '/')) {
                updateCurrentFileDisplay([], false); // Clear display
                if(editor) editor.setValue('// Current file was in a deleted directory.');
                document.getElementById('monacoEditorContainer').style.display = 'block'; // Ensure editor is visible
            }
            await listOpfsProjectFiles(projectName, currentPathSegments); 
        } catch (err) { displayEditorMessage(`Error deleting ${itemKind} '${itemName}': ${err.message}`, 'error'); }
    }
    
    uploadFilesBtn.addEventListener('click', () => {
        if (storageType !== 'opfs' || !currentDirectoryHandle) {
            displayEditorMessage('File upload: OPFS project & folder must be selected.', 'error'); return;
        }
        uploadFilesInput.click(); 
    });

    uploadFilesInput.addEventListener('change', async (event) => {
        const files = event.target.files;
        if (!files.length) return;
        if (!currentDirectoryHandle) {
            displayEditorMessage('Cannot upload: Current OPFS directory not established.', 'error'); return;
        }
        let successCount = 0; let errorCount = 0;
        for (const file of files) {
            try {
                const fileName = file.name;
                try {
                    await currentDirectoryHandle.getFileHandle(fileName);
                    if (!confirm(`File "${fileName}" already exists in this directory. Overwrite?`)) {
                        displayEditorMessage(`Skipped uploading "${fileName}".`, 'error'); 
                        continue; 
                    }
                } catch (e) { if (e.name !== 'NotFoundError') throw e; }
                const fileHandle = await currentDirectoryHandle.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(file); 
                await writable.close();
                successCount++;
            } catch (err) {
                errorCount++; console.error(`Error uploading file ${file.name}:`, err);
                displayEditorMessage(`Error uploading ${file.name}: ${err.message}`, 'error');
            }
        }
        if (successCount > 0) displayEditorMessage(`${successCount} file(s) uploaded successfully.`, 'success');
        if (errorCount > 0 && successCount === 0) displayEditorMessage(`${errorCount} file(s) failed to upload.`, 'error');
        else if (errorCount > 0) displayEditorMessage(`Completed with ${successCount} successes and ${errorCount} errors.`, 'error');
        
        await listOpfsProjectFiles(currentProject, currentPathSegments); 
        event.target.value = null; 
    });

    uploadFolderBtn.addEventListener('click', () => {
        if (storageType !== 'opfs' || !currentDirectoryHandle) {
            displayEditorMessage('Folder upload: OPFS project & folder must be selected.', 'error'); return;
        }
        uploadFolderInput.click();
    });

    uploadFolderInput.addEventListener('change', async (event) => {
        const files = event.target.files;
        if (!files.length) return;
        if (!currentDirectoryHandle) {
            displayEditorMessage('Cannot upload folder: Current OPFS directory not established.', 'error'); return;
        }
        displayEditorMessage('Starting folder upload... This may take a moment.', 'success');
        let overallSuccess = true;
        const uploadedFolderNames = new Set(); 

        for (const file of files) {
            try {
                const pathSegments = file.webkitRelativePath.split('/').filter(segment => segment !== ''); 
                if (pathSegments.length === 0) continue; 

                const fileName = pathSegments.pop(); 
                let parentDirHandleInOpfs = currentDirectoryHandle; 

                for (const segment of pathSegments) {
                    if (segment === '.' || segment === '..') continue; 
                    if (pathSegments.indexOf(segment) === 0 && currentPathSegments.length === 0) { 
                        uploadedFolderNames.add(segment);
                    }
                    parentDirHandleInOpfs = await parentDirHandleInOpfs.getDirectoryHandle(segment, { create: true });
                }
                
                const fileHandleInOpfs = await parentDirHandleInOpfs.getFileHandle(fileName, { create: true });
                const writable = await fileHandleInOpfs.createWritable();
                await writable.write(file); 
                await writable.close();
            } catch (err) {
                console.error(`Error uploading ${file.webkitRelativePath}:`, err);
                displayEditorMessage(`Error with ${file.webkitRelativePath}: ${err.message}`, 'error');
                overallSuccess = false;
            }
        }
        if (overallSuccess) {
            displayEditorMessage('Folder upload completed successfully!', 'success');
        } else {
            displayEditorMessage('Folder upload completed with some errors. Check console.', 'error');
        }
        
        uploadedFolderNames.forEach(folderName => {
            const fullPathKey = [...currentPathSegments, folderName].join('/');
            expandedFolders[fullPathKey] = true;
        });

        await listOpfsProjectFiles(currentProject, currentPathSegments); 
        event.target.value = null; 
    });


    saveButton.addEventListener('click', () => {
      if (storageType === 'opfs') {
          if (currentOpenFileFullPath.length === 0 || !editor || !currentProject) {
              displayEditorMessage('No file selected or project context missing.', 'error'); return;
          }
          // Ensure it's not an image trying to be saved by editor
          const shortFileName = currentOpenFileFullPath[currentOpenFileFullPath.length-1];
          const extension = shortFileName.split('.').pop().toLowerCase();
          if(imageExtensions.includes(extension)){
              displayEditorMessage('Cannot save image with text editor. Upload a new version if needed.', 'error');
              return;
          }
          saveOpfsFile(currentProject, currentOpenFileFullPath, editor.getValue()); 
          return;
      }
      const backendFileName = currentOpenFileFullPath.length > 0 ? currentOpenFileFullPath[currentOpenFileFullPath.length-1] : '';
      if (!currentProject || !backendFileName || !editor) { 
        displayEditorMessage('No file open or editor not ready.', 'error'); return;
      }
      const content = editor.getValue(); 
      fetch(`${API_BASE_URL}/file?project=${encodeURIComponent(currentProject)}&filename=${encodeURIComponent(backendFileName)}`, {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ content: content })
      })
      .then(r => r.ok ? r.json() : r.json().then(e => Promise.reject(e)))
      .then(d => d.message && d.message.toLowerCase().includes('saved') ? displayEditorMessage('File saved (backend)!', 'success') : Promise.reject(new Error(d.message || 'Unknown error')))
      .catch(e => displayEditorMessage(`Save error (backend): ${e.message || 'Unknown error'}`, 'error'));
    });

    document.addEventListener('DOMContentLoaded', async () => {
      const themeSelector = document.getElementById('themeSelector');
      const params = new URLSearchParams(window.location.search);
      currentProject = params.get('project');
      storageType = params.get('storage') === 'opfs' ? 'opfs' : 'backend'; 

      const opfsSupported = navigator.storage && navigator.storage.getDirectory;
      if (storageType === 'opfs' && !opfsSupported) {
        displayEditorMessage('OPFS API not supported.', 'error');
      }

      // Close context menu if clicking outside
      document.addEventListener('click', (e) => {
        if (currentOpenContextMenu && !currentOpenContextMenu.contains(e.target) && 
            e.target !== currentOpenContextMenu && 
            !e.target.classList.contains('context-menu-btn')) { 
          closeCurrentContextMenu();
        }
        // Close move modal if click is outside of its content
        if (moveItemModal.style.display === 'block' && e.target === moveItemModal) {
            closeMoveModal();
        }
      });

      function closeCurrentContextMenu() {
        if (currentOpenContextMenu) {
            currentOpenContextMenu.style.display = 'none';
            currentOpenContextMenu = null;
        }
      }
      
      // Move Modal Event Listeners
      moveModalCloseBtn.addEventListener('click', closeMoveModal);
      moveModalCancelBtn.addEventListener('click', closeMoveModal);

      // Close Project Button Event Listener
      if(closeProjectBtn) {
        closeProjectBtn.addEventListener('click', () => {
          window.location.href = 'index.html';
        });
      }

      // Export Project Button Event Listener
      if(exportProjectBtn) {
        exportProjectBtn.addEventListener('click', async () => {
            if (storageType !== 'opfs') {
                displayEditorMessage('Export is only available for OPFS projects.', 'error');
                return;
            }
            if (!currentProject || !rootProjectDirHandle) {
                displayEditorMessage('No active OPFS project to export.', 'error');
                return;
            }

            const formatInput = prompt("Export format: Enter 'ZIP' or 'RWMOD' (case-insensitive)", "ZIP");
            if (formatInput === null) return; // User cancelled

            const format = formatInput.trim().toUpperCase();
            if (format !== 'ZIP' && format !== 'RWMOD') {
                displayEditorMessage("Invalid export format. Please enter 'ZIP' or 'RWMOD'.", 'error');
                return;
            }
            
            await processProjectExport(currentProject, rootProjectDirHandle, format);
        });
      }

      // New Folder button in Move Modal
      moveModalNewFolderBtn.addEventListener('click', async () => {
        const currentBrowsingHandle = moveModalCurrentBrowsingPathArray.length === 0 ? 
            rootProjectDirHandle : 
            await getDirectoryHandleByPath(rootProjectDirHandle, moveModalCurrentBrowsingPathArray, false);

        if (!currentBrowsingHandle) {
            displayEditorMessage('Cannot determine current path in modal to create folder.', 'error');
            return;
        }
        
        const newFolderName = prompt(`Create new folder in '/${moveModalCurrentBrowsingPathArray.join('/')}':`);
        if (!newFolderName || newFolderName.trim() === '') return;
        if (newFolderName.includes('/') || newFolderName.includes('\\') || newFolderName === '.' || newFolderName === '..') {
            displayEditorMessage('Invalid folder name.', 'error'); return;
        }
        try {
            await currentBrowsingHandle.getDirectoryHandle(newFolderName.trim(), { create: true });
            displayEditorMessage(`Folder "${newFolderName.trim()}" created.`, 'success');
            await populateMoveModalDirectoryList(moveModalCurrentBrowsingPathArray); // Refresh modal list
        } catch (err) {
            if (err.name === 'NoModificationAllowedError') { // Often means it already exists
                 displayEditorMessage(`Folder "${newFolderName.trim()}" already exists or cannot be created.`, 'error');
            } else {
                displayEditorMessage(`Error creating folder: ${err.message}`, 'error');
            }
            console.error(err);
        }
      });

      // Placeholder for Move Here button in modal
      moveModalMoveHereBtn.addEventListener('click', async () => {
        // This is where the actual move logic will be integrated later.
        // For now, it will just log and close.
        console.log("Attempting to move:", sourceItemPathArrayToMove, "to", moveModalCurrentBrowsingPathArray);
        
        // --- Re-integrate logic from old handleMoveEntry ---
        const sourceName = sourceItemNameToMove; // Already stored
        const sourceFullPath = sourceItemPathArrayToMove.join('/');
        const destinationDirSegments = [...moveModalCurrentBrowsingPathArray];
        const destinationDirFullPath = destinationDirSegments.join('/');

        // --- Basic Validations (from old handleMoveEntry) ---
        if (sourceItemKindToMove === 'directory') {
            if (destinationDirFullPath === sourceFullPath) {
                displayEditorMessage('Cannot move a directory into itself.', 'error'); return;
            }
            if (destinationDirFullPath.startsWith(sourceFullPath + '/')) {
                displayEditorMessage('Cannot move a directory into its own subdirectory.', 'error'); return;
            }
        }
        const sourceParentPath = sourceItemPathArrayToMove.slice(0, -1).join('/');
        if (destinationDirFullPath === sourceParentPath) {
            displayEditorMessage(`'${sourceName}' is already in the folder '${destinationDirFullPath || "/ (root)"}'. No move performed.`, 'error');
            return;
        }

        try {
            let targetDestDirHandle;
            if (destinationDirSegments.length === 0) {
                targetDestDirHandle = rootProjectDirHandle;
            } else {
                targetDestDirHandle = await getDirectoryHandleByPath(rootProjectDirHandle, destinationDirSegments, false); // Ensure target exists before moving
            }

            // Check for name conflict (modified from old handleMoveEntry)
            try {
                if (sourceItemKindToMove === 'file') {
                    await targetDestDirHandle.getFileHandle(sourceName);
                } else {
                    await targetDestDirHandle.getDirectoryHandle(sourceName);
                }
                if (!confirm(`An item named '${sourceName}' already exists in '/${destinationDirFullPath}'. Overwrite?`)) {
                    displayEditorMessage('Move cancelled by user due to name conflict.', 'error'); return;
                }
                // If confirmed, need to delete existing item before move. This is complex.
                // For now, let's assume moveOpfsFile/Directory will handle overwrite if destination exists,
                // OR we prevent overwrite by default. The current moveOpfsFile/Directory try to create,
                // which might fail if item exists. They don't explicitly overwrite.
                // Simplification: For now, let's prevent overwrite. The user should delete first if they want to "overwrite" by moving.
                // The `moveOpfsFile/Directory` create new and delete old. If target exists, creation of new might fail or behave unexpectedly.
                // The original `handleMoveEntry` had a confirm for overwrite, but it didn't implement the actual overwrite.
                // Let's stick to "fail if target exists" for now, which is default for getFileHandle/getDirectoryHandle without create:true for target.
                 displayEditorMessage(`An item named '${sourceName}' already exists in the destination. Move operation aborted.`, 'error');
                 return;

            } catch (e) {
                if (e.name !== 'NotFoundError') { throw e; }
                // NotFoundError is good, means no conflict.
            }

            let moveSuccess = false;
            if (sourceItemKindToMove === 'file') {
                moveSuccess = await moveOpfsFile(currentProject, sourceItemPathArrayToMove, targetDestDirHandle, sourceName);
            } else if (sourceItemKindToMove === 'directory') {
                moveSuccess = await moveOpfsDirectory(currentProject, sourceItemPathArrayToMove, targetDestDirHandle, sourceName);
            }

            if (moveSuccess) {
                // Update UI (main explorer)
                await listOpfsProjectFiles(currentProject, currentPathSegments); // Refresh based on main explorer's current path

                // Update currentOpenFileFullPath
                if (currentOpenFileFullPath.length > 0) {
                    const currentOpenFullPathStr = currentOpenFileFullPath.join('/');
                    if (currentOpenFullPathStr === sourceFullPath) {
                        const newOpenFileFullPath = [...destinationDirSegments, sourceName];
                        updateCurrentFileDisplay(newOpenFileFullPath, imageExtensions.includes(sourceName.split('.').pop().toLowerCase()));
                    } else if (sourceItemKindToMove === 'directory' && currentOpenFullPathStr.startsWith(sourceFullPath + '/')) {
                        const relativePathWithinMovedDir = currentOpenFileFullPath.slice(sourceItemPathArrayToMove.length).join('/');
                        const newOpenFileFullPath = [...destinationDirSegments, sourceName, ...relativePathWithinMovedDir.split('/')];
                        updateCurrentFileDisplay(newOpenFileFullPath, imageExtensions.includes(newOpenFileFullPath[newOpenFileFullPath.length-1].split('.').pop().toLowerCase()));
                    }
                }
                // Update expandedFolders
                if (sourceItemKindToMove === 'directory') {
                    const oldPathKey = sourceItemPathArrayToMove.join('/');
                    const newPathKey = [...destinationDirSegments, sourceName].join('/');
                    if (expandedFolders[oldPathKey]) {
                        delete expandedFolders[oldPathKey];
                        expandedFolders[newPathKey] = true; 
                    }
                    const prefixToRemove = oldPathKey + '/';
                    const prefixToAdd = newPathKey + '/';
                    for (const key in expandedFolders) {
                        if (key.startsWith(prefixToRemove)) {
                            const newSubKey = prefixToAdd + key.substring(prefixToRemove.length);
                            expandedFolders[newSubKey] = expandedFolders[key];
                            delete expandedFolders[key];
                        }
                    }
                }
                displayEditorMessage(`'${sourceName}' moved successfully to '/${destinationDirFullPath || "(root)"}'.`, 'success');
            }
        } catch (error) {
            console.error('Error during move operation from modal:', error);
            displayEditorMessage(`Move failed: ${error.message}`, 'error');
            await listOpfsProjectFiles(currentProject, currentPathSegments); // Refresh on error
        }
        closeMoveModal();
      });
      

      newFileBtn.disabled = storageType !== 'opfs' || !opfsSupported;
      newDirectoryBtn.disabled = storageType !== 'opfs' || !opfsSupported;
      uploadFilesBtn.disabled = storageType !== 'opfs' || !opfsSupported; 
      uploadFolderBtn.disabled = storageType !== 'opfs' || !opfsSupported; 

      require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' }});
      require(['vs/editor/editor.main'], async function() { 
          const savedTheme = localStorage.getItem('monacoTheme') || 'vs-dark';
          const savedFontSize = parseInt(localStorage.getItem('editorFontSize'), 10) || 14;
          
          editor = monaco.editor.create(document.getElementById('monacoEditorContainer'), {
              value: '// Select a file or create one.', 
              language: 'plaintext', 
              theme: savedTheme, 
              automaticLayout: true,
              fontSize: savedFontSize 
          });
          fontSizeInput.value = savedFontSize;

          window.addEventListener('resize', () => { if (editor) editor.layout(); });

          if (themeSelector) {
            themeSelector.value = savedTheme;
            themeSelector.addEventListener('change', () => {
              const newTheme = themeSelector.value;
              monaco.editor.setTheme(newTheme);
              localStorage.setItem('monacoTheme', newTheme);
            });
          }

          function updateEditorFontSize(newSize) {
            const size = parseInt(newSize, 10);
            if (isNaN(size) || size < 8 || size > 72) {
              displayEditorMessage('Font size must be between 8 and 72.', 'error');
              // Optionally reset to a valid value or the previous value
              fontSizeInput.value = editor.getOption(monaco.editor.EditorOption.fontSize);
              return;
            }
            if (editor) {
              editor.updateOptions({ fontSize: size });
            }
            fontSizeInput.value = size;
            localStorage.setItem('editorFontSize', size);
          }

          fontSizeInput.addEventListener('input', () => {
            updateEditorFontSize(fontSizeInput.value);
          });

          increaseFontSizeBtn.addEventListener('click', () => {
            let currentSize = parseInt(fontSizeInput.value, 10);
            if (isNaN(currentSize)) currentSize = 14; // Default if input is somehow not a number
            updateEditorFontSize(Math.min(72, currentSize + 1));
          });

          decreaseFontSizeBtn.addEventListener('click', () => {
            let currentSize = parseInt(fontSizeInput.value, 10);
            if (isNaN(currentSize)) currentSize = 14; // Default if input is somehow not a number
            updateEditorFontSize(Math.max(8, currentSize - 1));
          });
          
          if (currentProject) {
            document.title = `Editor - ${currentProject} (${storageType.toUpperCase()})`;
            if (storageType === 'opfs') {
                if (opfsSupported) {
                    try { 
                        const opfsRoot = await navigator.storage.getDirectory();
                        rootProjectDirHandle = await opfsRoot.getDirectoryHandle(currentProject);
                        await listOpfsProjectFiles(currentProject); 
                    } catch (err) {
                        displayEditorMessage(`Error accessing project '${currentProject}' in OPFS: ${err.message}`, 'error');
                        fileListUl.innerHTML = '<li>Error loading project from OPFS.</li>';
                    }
                } else {  fileListUl.innerHTML = '<li>OPFS Not Supported.</li>'; }
            } else { fetchProjectFilesBackend(currentProject); }
            updateCurrentFileDisplay([]); 
          } else {
            displayEditorMessage('No project specified. Open from dashboard.', 'error');
            fileListUl.innerHTML = '<li>No project loaded.</li>';
            currentPathDisplayElement.textContent = 'No Project'; 
            updateCurrentFileDisplay([]);
            if (editor) editor.setValue('// No project loaded.');
          }
      });
    });
  </script>
</body>
</html>